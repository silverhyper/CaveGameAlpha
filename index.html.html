<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CaveGame - Drag & Drop Fix with Hand & Recipe Book</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #inventory-screen, #crafting-table-screen, #recipe-book {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #8b5a2b; width: 600px; height: 400px; padding: 20px;
            display: none; border: 5px solid #5a3e1b;
        }
        #inventory-screen table, #crafting-table-screen table, #recipe-book table {
            width: 50%; height: 100%; border-collapse: collapse; float: left;
        }
        #inventory-screen td, #crafting-table-screen td, #recipe-book td {
            width: 50px; height: 50px; border: 2px solid #3c2f1b; background: #c19a6b;
            text-align: center; vertical-align: middle; position: relative; cursor: pointer;
        }
        .item-texture { 
            width: 40px; height: 40px; margin: 5px auto; 
            border: 2px solid #444; box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background-size: cover;
        }
        .item-count { 
            position: absolute; bottom: 2px; right: 2px; font-size: 12px; 
            color: white; text-shadow: 1px 1px black; 
        }
        #hotbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(128, 128, 128, 0.8); padding: 5px; border: 3px solid #5a3e1b;
        }
        #hotbar table { border-collapse: collapse; }
        #hotbar td {
            width: 64px; height: 64px; border: 2px solid #3c2f1b; background: #8b8b8b;
            text-align: center; vertical-align: middle; position: relative;
        }
        #hotbar td.selected { border: 3px solid #ffd700; }
        #hp-bar {
            position: absolute; bottom: 90px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 20px; background: #333; border: 2px solid #000;
            pointer-events: none;
        }
        #hp-fill {
            height: 100%; background: red; transition: width 0.2s;
        }
        #player-hand {
            position: absolute; bottom: 20px; left: 20px; width: 64px; height: 64px;
            pointer-events: none; background-size: cover;
        }
        #crafting-grid, #crafting-table-grid {
            float: right; width: 45%; height: 100%; padding: 10px; text-align: center;
        }
        #crafting-grid table, #crafting-table-grid table {
            width: 150px; height: 150px; border-collapse: collapse; margin: 0 auto;
        }
        #crafting-grid td, #crafting-table-grid td {
            width: 50px; height: 50px; border: 2px solid #3c2f1b; background: #c19a6b;
            text-align: center; vertical-align: middle; position: relative; cursor: pointer;
        }
        .arrow {
            font-size: 24px; margin: 10px 0; color: #fff; text-shadow: 1px 1px black;
        }
        #craft-result, #craft3-result {
            width: 60px; height: 60px; border: 2px solid #3c2f1b; background: #c19a6b;
            margin: 10px auto 0; text-align: center; vertical-align: middle; position: relative; cursor: pointer; float: right;
        }
        #craft-result .item-texture, #craft3-result .item-texture {
            width: 50px; height: 50px;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none; border: 2px solid white;
        }
        #recipe-book-content {
            height: 300px; overflow-y: auto;
        }
        #recipe-book-content td {
            cursor: pointer; padding: 5px;
        }
        #recipe-book-content .recipe-item {
            display: inline-block; width: 50px; height: 50px; background-size: cover;
        }

        /* PNG Textures */
        .wood-texture { background-image: url('https://art.pixilart.com/4f7e90163ba6436.png'); }
        .dirt-texture { background-image: url('https://cdn.pixabay.com/photo/2020/12/10/12/10/minecraft-5820118_960_720.png'); }
        .pickaxe-texture { background-image: url('https://minecraft.wiki/images/Wooden_Pickaxe_JE3_BE3.png?fa797'); }
        .stone-pickaxe-texture { background-image: url('https://static.wikia.nocookie.net/minecraft_gamepedia/images/c/c4/Stone_Pickaxe_JE2_BE2.png/revision/latest?cb=20200217234007'); background-color: transparent; }
        .axe-texture { background-image: url('https://static.wikia.nocookie.net/minecraft_gamepedia/images/5/56/Wooden_Axe_JE2_BE2.png/revision/latest?cb=20200217234355'); }
        .planks-texture { background-image: url('https://i.pinimg.com/736x/c1/26/4b/c1264b2eefbbab5272330b4e6a7343b4.jpg'); }
        .crafting-table-texture { background-image: url('https://www.fractalcamo.com/uploads/5/9/0/2/5902948/s189772745713394276_p3852_i146_w750.jpeg'); }
        .mutton-texture { background-image: url('https://p.novaskin.me/5319933761.png'); }
        .stone-texture { background-image: url('https://i.pinimg.com/736x/d3/5c/0c/d35c0c58fff90987e9532e808ded0008.jpg'); }
        .stick-texture { background: #8b5a2b; }
        .leaves-texture { background: #00ff00; }
        .sheep-texture { background-image: url('https://i.pinimg.com/736x/02/f3/9f/02f39f62062b1c479afa97bd0a484c92.jpg'); background-color: transparent; }
        .pig-texture { background-image: url('https://i.pinimg.com/736x/d2/f8/4e/d2f84eb7f6ff62b2cce285b79bc66088.jpg'); background-color: transparent; }
        .cow-texture { background-image: url('https://i.pinimg.com/736x/3f/4f/45/3f4f45cd6718f98f1aea4c888d03384a.jpg'); background-color: transparent; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="inventory-screen">
        <table id="inventory-table-main">
            <tr><td id="inv-0"></td><td id="inv-1"></td><td id="inv-2"></td></tr>
            <tr><td id="inv-3"></td><td id="inv-4"></td><td id="inv-5"></td></tr>
        </table>
        <div id="crafting-grid">
            <table id="crafting-table">
                <tr><td id="craft-0"></td><td id="craft-1"></td><td id="craft-2"></td></tr>
                <tr><td id="craft-3"></td><td id="craft-4"></td><td id="craft-5"></td></tr>
                <tr><td id="craft-6"></td><td id="craft-7"></td><td id="craft-8"></td></tr>
            </table>
            <div class="arrow" style="float: right; margin-left: 10px;">➡️</div>
            <div id="craft-result"></div>
        </div>
    </div>
    <div id="crafting-table-screen">
        <table id="inventory-table-crafting">
            <tr><td id="inv-0"></td><td id="inv-1"></td><td id="inv-2"></td></tr>
            <tr><td id="inv-3"></td><td id="inv-4"></td><td id="inv-5"></td></tr>
        </table>
        <div id="crafting-table-grid">
            <table id="crafting-table-3x3">
                <tr><td id="craft3-0"></td><td id="craft3-1"></td><td id="craft3-2"></td></tr>
                <tr><td id="craft3-3"></td><td id="craft3-4"></td><td id="craft3-5"></td></tr>
                <tr><td id="craft3-6"></td><td id="craft3-7"></td><td id="craft3-8"></td></tr>
            </table>
            <div class="arrow" style="float: right; margin-left: 10px;">➡️</div>
            <div id="craft3-result"></div>
        </div>
    </div>
    <div id="recipe-book">
        <div id="recipe-book-content"></div>
    </div>
    <div id="hotbar">
        <table>
            <tr><td id="hot-0" class="selected"></td><td id="hot-1"></td><td id="hot-2"></td></tr>
        </table>
    </div>
    <div id="hp-bar"><div id="hp-fill"></div></div>
    <div id="player-hand"></div>
    <div id="crosshair">+</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas') });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const worldSize = 64;
        const chunkSize = 16;
        const blockSize = 1;
        let player = {
            x: worldSize / 2, y: 10, z: worldSize / 2, vy: 0, yaw: 0, pitch: 0,
            inventory: [null, null, null, null, null, null],
            hotbar: [null, null, null],
            crafting: [null, null, null, null, null, null, null, null, null],
            crafting3x3: [null, null, null, null, null, null, null, null, null],
            selectedHotbar: 0,
            heldItem: null,
            tools: { pickaxe: false, axe: false, stonePickaxe: false },
            health: 10
        };
        const chunks = {};
        const entities = {};
        const clock = new THREE.Clock();
        let inventoryOpen = false;
        let craftingTableOpen = false;
        let recipeBookOpen = false;
        let breakStartTime = null;
        const breakTimeWood = 1;
        const breakTimeStone = 3;
        let lastSheepSpawnTime = Date.now();
        let lastPigSpawnTime = Date.now();
        let lastCowSpawnTime = Date.now();

        // Materials with textures and fallbacks
        const materials = {
            bedrock: new THREE.MeshLambertMaterial({ color: 0x505050 }), // Black
            stone: new THREE.MeshLambertMaterial({ color: 0x808080 }),
            dirt: new THREE.MeshLambertMaterial({ color: 0x654321 }),
            grass: new THREE.MeshLambertMaterial({ color: 0x228b22 }),
            wood: new THREE.MeshLambertMaterial({ color: 0x8b4513 }),
            planks: new THREE.MeshLambertMaterial({ color: 0xd68a40 }),
            crafting_table: new THREE.MeshLambertMaterial({ color: 0xdeb887 }),
            leaves: new THREE.MeshLambertMaterial({ color: 0x00ff00 }),
            sheep: new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://i.pinimg.com/736x/02/f3/9f/02f39f62062b1c479afa97bd0a484c92.jpg', undefined, undefined, () => { console.log('Sheep texture failed'); }) }),
            pig: new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://i.pinimg.com/736x/d2/f8/4e/d2f84eb7f6ff62b2cce285b79bc66088.jpg', undefined, undefined, () => { console.log('Pig texture failed'); }) }),
            cow: new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://i.pinimg.com/736x/3f/4f/45/3f4f45cd6718f98f1aea4c888d03384a.jpg', undefined, undefined, () => { console.log('Cow texture failed'); }) })
        };
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load('https://cdn.pixabay.com/photo/2020/12/10/12/10/minecraft-5820118_960_720.png', (tex) => { materials.dirt.map = tex; console.log('Dirt loaded'); }, undefined, () => { materials.dirt.color.set(0x654321); console.log('Dirt texture failed, using fallback'); });
        textureLoader.load('https://art.pixilart.com/4f7e90163ba6436.png', (tex) => { materials.wood.map = tex; console.log('Wood loaded'); }, undefined, () => { materials.wood.color.set(0x8b4513); console.log('Wood texture failed, using fallback'); });
        textureLoader.load('https://i.pinimg.com/736x/c1/26/4b/c1264b2eefbbab5272330b4e6a7343b4.jpg', (tex) => { materials.planks.map = tex; console.log('Planks loaded'); }, undefined, () => { materials.planks.color.set(0xd68a40); console.log('Planks texture failed, using fallback'); });
        textureLoader.load('https://www.fractalcamo.com/uploads/5/9/0/2/5902948/s189772745713394276_p3852_i146_w750.jpeg', (tex) => { materials.crafting_table.map = tex; console.log('Crafting table loaded'); }, undefined, () => { materials.crafting_table.color.set(0xdeb887); console.log('Crafting table texture failed, using fallback'); });
        textureLoader.load('https://i.pinimg.com/736x/d3/5c/0c/d35c0c58fff90987e9532e808ded0008.jpg', (tex) => { materials.stone.map = tex; console.log('Stone loaded'); }, undefined, () => { materials.stone.color.set(0x808080); console.log('Stone texture failed, using fallback'); });
        textureLoader.load('https://minecraft.wiki/images/Wooden_Pickaxe_JE3_BE3.png?fa797', (tex) => { materials.pickaxe = new THREE.MeshBasicMaterial({ map: tex }); console.log('Wooden Pickaxe loaded'); }, undefined, () => { console.log('Wooden Pickaxe texture failed'); });
        textureLoader.load('https://static.wikia.nocookie.net/minecraft_gamepedia/images/5/56/Wooden_Axe_JE2_BE2.png/revision/latest?cb=20200217234355', (tex) => { materials.axe = new THREE.MeshBasicMaterial({ map: tex }); console.log('Wooden Axe loaded'); }, undefined, () => { console.log('Wooden Axe texture failed'); });
        textureLoader.load('https://static.wikia.nocookie.net/minecraft_gamepedia/images/c/c4/Stone_Pickaxe_JE2_BE2.png/revision/latest?cb=20200217234007', (tex) => { materials.stonePickaxe = new THREE.MeshBasicMaterial({ map: tex }); console.log('Stone Pickaxe loaded'); }, undefined, () => { console.log('Stone Pickaxe texture failed'); });

        // Pointer lock
        document.addEventListener('click', () => {
            if (!inventoryOpen && !craftingTableOpen && !recipeBookOpen) renderer.domElement.requestPointerLock();
        });
        let mouseLocked = false;
        document.addEventListener('pointerlockchange', () => {
            mouseLocked = document.pointerLockElement === renderer.domElement;
            document.getElementById('crosshair').style.display = mouseLocked && !inventoryOpen && !craftingTableOpen && !recipeBookOpen ? 'block' : 'none';
        });
        document.addEventListener('mousemove', (e) => {
            if (mouseLocked && !inventoryOpen && !craftingTableOpen && !recipeBookOpen) {
                const sensitivity = 0.002;
                player.yaw -= e.movementX * sensitivity;
                player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.pitch - e.movementY * sensitivity));
                updateCrosshair();
            }
        });

        function updateCrosshair() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(Object.values(chunks).flatMap(chunk => Object.values(chunk.keys)).concat(Object.values(entities)));
            const crosshair = document.getElementById('crosshair');
            if (intersects.length > 0 && intersects[0].distance < 5) crosshair.style.borderColor = 'red';
            else crosshair.style.borderColor = 'white';
        }

        // Inventory, crafting, and recipe book toggle
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'e') {
                if (craftingTableOpen) {
                    craftingTableOpen = false;
                    document.getElementById('crafting-table-screen').style.display = 'none';
                    for (let i = 0; i < 9; i++) {
                        if (player.crafting3x3[i]) {
                            addToInventoryWithCount(player.crafting3x3[i].type, player.crafting3x3[i].count);
                            player.crafting3x3[i] = null;
                        }
                    }
                    if (mouseLocked) renderer.domElement.requestPointerLock();
                } else if (recipeBookOpen) {
                    recipeBookOpen = false;
                    document.getElementById('recipe-book').style.display = 'none';
                    document.exitPointerLock();
                } else if (!inventoryOpen) {
                    inventoryOpen = true;
                    document.getElementById('inventory-screen').style.display = 'block';
                    document.exitPointerLock();
                } else {
                    inventoryOpen = false;
                    document.getElementById('inventory-screen').style.display = 'none';
                    for (let i = 0; i < 9; i++) {
                        if (player.crafting[i]) {
                            addToInventoryWithCount(player.crafting[i].type, player.crafting[i].count);
                            player.crafting[i] = null;
                        }
                    }
                    if (mouseLocked) renderer.domElement.requestPointerLock();
                }
                updateUI();
            } else if (e.key.toLowerCase() === 'r') { // Toggle recipe book
                if (recipeBookOpen) {
                    recipeBookOpen = false;
                    document.getElementById('recipe-book').style.display = 'none';
                    document.exitPointerLock();
                } else {
                    recipeBookOpen = true;
                    document.getElementById('recipe-book').style.display = 'block';
                    document.exitPointerLock();
                    populateRecipeBook();
                }
                updateUI();
            }
        });

        // Hotbar selection
        document.addEventListener('wheel', (e) => {
            if (!inventoryOpen && !craftingTableOpen && !recipeBookOpen) {
                player.selectedHotbar = (player.selectedHotbar + (e.deltaY > 0 ? 1 : -1) + 3) % 3;
                updateUI();
            }
        });

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(10, 20, 10);
        scene.add(sun);

        // Noise for terrain
        function noise(x, z) {
            return (Math.sin(x * 0.1) + Math.sin(z * 0.1)) * 2;
        }

        // Chunk management
        function generateChunk(cx, cz) {
            const chunkKey = `${cx},${cz}`;
            if (chunks[chunkKey]) return;
            chunks[chunkKey] = { keys: {} };
            const startX = cx * chunkSize;
            const startZ = cz * chunkSize;
            for (let x = startX; x < startX + chunkSize; x++) {
                for (let z = startZ; z < startZ + chunkSize; z++) {
                    if (x >= worldSize || z >= worldSize) continue;
                    const keyBedrock = `${x},0,${z}`;
                    chunks[chunkKey].keys[keyBedrock] = new THREE.Mesh(
                        new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                        materials.bedrock
                    );
                    chunks[chunkKey].keys[keyBedrock].position.set(x, 0, z);
                    const height = Math.max(2, Math.floor(noise(x, z) + 3));
                    for (let y = 1; y < height - 3; y++) { // Maintain more stone layers
                        const keyStone = `${x},${y},${z}`;
                        chunks[chunkKey].keys[keyStone] = new THREE.Mesh(
                            new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                            materials.stone
                        );
                        chunks[chunkKey].keys[keyStone].position.set(x, y, z);
                    }
                    const keyDirt = `${x},${height - 1},${z}`;
                    chunks[chunkKey].keys[keyDirt] = new THREE.Mesh(
                        new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                        materials.dirt
                    );
                    chunks[chunkKey].keys[keyDirt].position.set(x, height - 1, z);
                    const keyGrass = `${x},${height},${z}`;
                    chunks[chunkKey].keys[keyGrass] = new THREE.Mesh(
                        new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                        materials.grass
                    );
                    chunks[chunkKey].keys[keyGrass].position.set(x, height, z);
                    if (Math.random() < 0.05 && height < 5) {
                        const treeHeight = Math.floor(Math.random() * 3) + 4;
                        for (let y = height + 1; y <= height + treeHeight; y++) {
                            const keyWood = `${x},${y},${z}`;
                            chunks[chunkKey].keys[keyWood] = new THREE.Mesh(
                                new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                                materials.wood
                            );
                            chunks[chunkKey].keys[keyWood].position.set(x, y, z);
                        }
                        for (let y = height + treeHeight - 1; y <= height + treeHeight + 1; y++) {
                            const radius = y === height + treeHeight + 1 ? 1 : 2;
                            for (let dx = -radius; dx <= radius; dx++) {
                                for (let dz = -radius; dz <= radius; dz++) {
                                    if (Math.random() < 0.7 && !(dx === 0 && dz === 0)) {
                                        const keyLeaves = `${x + dx},${y},${z + dz}`;
                                        if (!chunks[chunkKey].keys[keyLeaves]) {
                                            chunks[chunkKey].keys[keyLeaves] = new THREE.Mesh(
                                                new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                                                materials.leaves
                                            );
                                            chunks[chunkKey].keys[keyLeaves].position.set(x + dx, y, z + dz);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            console.log(`Generated chunk ${chunkKey} with ${Object.keys(chunks[chunkKey].keys).length} blocks`);
            Object.values(chunks[chunkKey].keys).forEach(block => scene.add(block));
        }

        function unloadChunk(cx, cz) {
            const chunkKey = `${cx},${cz}`;
            if (!chunks[chunkKey]) return;
            Object.values(chunks[chunkKey].keys).forEach(block => scene.remove(block));
            delete chunks[chunkKey];
        }

        function updateChunks() {
            const cx = Math.floor(player.x / chunkSize);
            const cz = Math.floor(player.z / chunkSize);
            const renderDistance = 1;
            for (let dx = -renderDistance; dx <= renderDistance; dx++) {
                for (let dz = -renderDistance; dz <= renderDistance; dz++) {
                    const chunkX = cx + dx;
                    const chunkZ = cz + dz;
                    if (chunkX >= 0 && chunkX < worldSize / chunkSize && chunkZ >= 0 && chunkZ < worldSize / chunkSize) {
                        generateChunk(chunkX, chunkZ);
                    }
                }
            }
            Object.keys(chunks).forEach(key => {
                const [x, z] = key.split(',').map(Number);
                if (Math.abs(x - cx) > renderDistance || Math.abs(z - cz) > renderDistance) unloadChunk(x, z);
            });
        }

        // Block and entity interaction
        const raycaster = new THREE.Raycaster();
        function onClick(event) {
            if (!mouseLocked || inventoryOpen || craftingTableOpen || recipeBookOpen) return;
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(Object.values(chunks).flatMap(chunk => Object.values(chunk.keys)).concat(Object.values(entities)));
            if (intersects.length > 0 && intersects[0].distance < 5) {
                const intersect = intersects[0];
                const object = intersect.object;
                const pos = object.position;
                const key = `${pos.x},${pos.y},${pos.z}`;
                const chunkKey = `${Math.floor(pos.x / chunkSize)},${Math.floor(pos.z / chunkSize)}`;

                if (event.button === 0) { // Break or attack
                    if (object.userData.type === 'sheep' || object.userData.type === 'pig' || object.userData.type === 'cow') {
                        attackEntity(object.userData.id);
                    } else {
                        let itemType = null;
                        let breakTime = 0;
                        const mat = object.material;
                        if (mat === materials.wood) {
                            itemType = 'wood';
                            breakTime = player.tools.axe ? breakTimeWood * 1000 : breakTimeWood * 2 * 1000; // Axe breaks wood slightly faster than fist
                        } else if (mat === materials.dirt) itemType = 'dirt';
                        else if (mat === materials.grass) itemType = 'dirt'; // Grass drops dirt
                        else if (mat === materials.planks) itemType = 'planks';
                        else if (mat === materials.crafting_table) itemType = 'crafting_table';
                        else if (mat === materials.stone) {
                            if (player.tools.pickaxe || player.tools.stonePickaxe) {
                                itemType = 'stone';
                                breakTime = player.tools.stonePickaxe ? breakTimeStone * 500 : breakTimeStone * 1000; // Stone pickaxe mines faster than wooden
                            } else {
                                return; // Cannot mine stone without a pickaxe
                            }
                        } else if (mat === materials.leaves) itemType = 'leaves';

                        if (itemType || breakTime) {
                            breakStartTime = breakStartTime || {};
                            breakStartTime[key] = Date.now();
                            setTimeout(() => {
                                delete breakStartTime[key];
                                if (chunks[chunkKey]?.keys[key]) {
                                    scene.remove(chunks[chunkKey].keys[key]);
                                    delete chunks[chunkKey].keys[key];
                                    if (itemType) addToInventory(itemType);
                                    updateUI();
                                }
                            }, breakTime);
                        }
                    }
                } else if (event.button === 2) { // Place or interact
                    if (object.material === materials.crafting_table) {
                        craftingTableOpen = true;
                        document.getElementById('crafting-table-screen').style.display = 'block';
                        document.exitPointerLock();
                        updateUI();
                        return;
                    }
                    const selectedItem = player.hotbar[player.selectedHotbar];
                    if (selectedItem && selectedItem.count > 0) {
                        const normal = intersect.face.normal;
                        const newPos = pos.clone().add(normal);
                        const newKey = `${newPos.x},${newPos.y},${newPos.z}`;
                        const newChunkKey = `${Math.floor(newPos.x / chunkSize)},${Math.floor(newPos.z / chunkSize)}`;
                        if (!chunks[newChunkKey]) chunks[newChunkKey] = { keys: {} };
                        if (!chunks[newChunkKey].keys[newKey] && newPos.y > 0 && newPos.x < worldSize && newPos.z < worldSize) {
                            chunks[newChunkKey].keys[newKey] = new THREE.Mesh(
                                new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                                materials[selectedItem.type] || materials.dirt
                            );
                            chunks[newChunkKey].keys[newKey].position.copy(newPos);
                            scene.add(chunks[newChunkKey].keys[newKey]);
                            selectedItem.count--;
                            if (selectedItem.count === 0) player.hotbar[player.selectedHotbar] = null;
                            updateUI();
                        }
                    }
                }
            }
        }
        document.addEventListener('mousedown', onClick);
        document.addEventListener('contextmenu', (e) => e.preventDefault());

        // Inventory management
        function addToInventory(type) {
            addToInventoryWithCount(type, 1);
        }

        function addToInventoryWithCount(type, count) {
            for (let i = 0; i < player.hotbar.length; i++) {
                if (player.hotbar[i] && player.hotbar[i].type === type) {
                    player.hotbar[i].count += count;
                    return;
                }
            }
            for (let i = 0; i < player.inventory.length; i++) {
                if (player.inventory[i] && player.inventory[i].type === type) {
                    player.inventory[i].count += count;
                    return;
                }
            }
            for (let i = 0; i < player.hotbar.length; i++) {
                if (!player.hotbar[i]) {
                    player.hotbar[i] = { type, count };
                    return;
                }
            }
            for (let i = 0; i < player.inventory.length; i++) {
                if (!player.inventory[i]) {
                    player.inventory[i] = { type, count };
                    return;
                }
            }
        }

        // UI update
        function updateUI() {
            const tables = ['inventory-table-main', 'inventory-table-crafting'];
            tables.forEach(tableId => {
                const table = document.getElementById(tableId);
                if (table) {
                    for (let i = 0; i < 6; i++) {
                        const slot = table.querySelector(`#inv-${i}`);
                        slot.innerHTML = '';
                        if (player.inventory[i] && player.inventory[i].count > 0) {
                            const textureClass = `${player.inventory[i].type}-texture`;
                            slot.innerHTML = `<div class="item-texture ${textureClass}"></div><span class="item-count">${player.inventory[i].count}</span>`;
                        }
                    }
                }
            });

            for (let i = 0; i < 3; i++) {
                const slot = document.getElementById(`hot-${i}`);
                slot.innerHTML = '';
                slot.classList.toggle('selected', i === player.selectedHotbar);
                if (player.hotbar[i] && player.hotbar[i].count > 0) {
                    const textureClass = `${player.hotbar[i].type}-texture`;
                    slot.innerHTML = `<div class="item-texture ${textureClass}"></div><span class="item-count">${player.hotbar[i].count}</span>`;
                }
            }

            if (inventoryOpen) {
                for (let i = 0; i < 9; i++) {
                    const slot = document.getElementById(`craft-${i}`);
                    slot.innerHTML = '';
                    if (player.crafting[i] && player.crafting[i].count > 0) {
                        const textureClass = `${player.crafting[i].type}-texture`;
                        slot.innerHTML = `<div class="item-texture ${textureClass}"></div><span class="item-count">${player.crafting[i].count}</span>`;
                    }
                }
            }
            if (craftingTableOpen) {
                for (let i = 0; i < 9; i++) {
                    const slot = document.getElementById(`craft3-${i}`);
                    slot.innerHTML = '';
                    if (player.crafting3x3[i] && player.crafting3x3[i].count > 0) {
                        const textureClass = `${player.crafting3x3[i].type}-texture`;
                        slot.innerHTML = `<div class="item-texture ${textureClass}"></div><span class="item-count">${player.crafting3x3[i].count}</span>`;
                    }
                }
            }
            updateCraftingResult();
            updateHPBar();
            updatePlayerHand();
        }

        function updateHPBar() {
            const hpFill = document.getElementById('hp-fill');
            hpFill.style.width = `${(player.health / 10) * 100}%`;
        }

        function updatePlayerHand() {
            const hand = document.getElementById('player-hand');
            const heldItem = player.hotbar[player.selectedHotbar];
            if (heldItem && heldItem.count > 0) {
                if (heldItem.type === 'wood') hand.style.backgroundImage = `url('https://art.pixilart.com/4f7e90163ba6436.png')`;
                else if (heldItem.type === 'dirt') hand.style.backgroundImage = `url('https://cdn.pixabay.com/photo/2020/12/10/12/10/minecraft-5820118_960_720.png')`;
                else if (heldItem.type === 'planks') hand.style.backgroundImage = `url('https://i.pinimg.com/736x/c1/26/4b/c1264b2eefbbab5272330b4e6a7343b4.jpg')`;
                else if (heldItem.type === 'crafting_table') hand.style.backgroundImage = `url('https://www.fractalcamo.com/uploads/5/9/0/2/5902948/s189772745713394276_p3852_i146_w750.jpeg')`;
                else if (heldItem.type === 'pickaxe') hand.style.backgroundImage = `url('https://minecraft.wiki/images/Wooden_Pickaxe_JE3_BE3.png?fa797')`;
                else if (heldItem.type === 'stonePickaxe') hand.style.backgroundImage = `url('https://static.wikia.nocookie.net/minecraft_gamepedia/images/c/c4/Stone_Pickaxe_JE2_BE2.png/revision/latest?cb=20200217234007')`;
                else if (heldItem.type === 'axe') hand.style.backgroundImage = `url('https://static.wikia.nocookie.net/minecraft_gamepedia/images/5/56/Wooden_Axe_JE2_BE2.png/revision/latest?cb=20200217234355')`;
                else if (heldItem.type === 'mutton') hand.style.backgroundImage = `url('https://p.novaskin.me/5319933761.png')`;
                else if (heldItem.type === 'stone') hand.style.backgroundImage = `url('https://i.pinimg.com/736x/d3/5c/0c/d35c0c58fff90987e9532e808ded0008.jpg')`;
                else hand.style.backgroundImage = `url('https://art.pixilart.com/4f7e90163ba6436.png')`; // Default fallback
                hand.style.display = 'block';
            } else {
                hand.style.display = 'none';
            }
        }

        // Click-to-pick-and-place
        let isDragging = false;
        document.querySelectorAll('#inventory-table-main td, #inventory-table-crafting td, #hotbar td, #crafting-table td, #crafting-table-3x3 td').forEach(slot => {
            slot.addEventListener('mousedown', (e) => {
                if (!inventoryOpen && !craftingTableOpen && !recipeBookOpen) return;
                e.preventDefault();
                const [prefix, index] = slot.id.split('-');
                const array = prefix === 'inv' ? player.inventory : prefix === 'hot' ? player.hotbar : prefix === 'craft' ? player.crafting : player.crafting3x3;
                if (!array[index] || array[index].count === 0) return;
                if (e.button === 0) { // Left click for full stack
                    player.heldItem = { type: array[index].type, count: array[index].count };
                    array[index] = null;
                    isDragging = true;
                    updateUI();
                } else if (e.button === 2) { // Right click for half stack (if > 1)
                    if (array[index].count > 1) {
                        player.heldItem = { type: array[index].type, count: Math.floor(array[index].count / 2) };
                        array[index].count -= player.heldItem.count;
                        isDragging = true;
                        updateUI();
                    } else {
                        player.heldItem = { type: array[index].type, count: 1 };
                        array[index].count--;
                        if (array[index].count === 0) array[index] = null;
                        isDragging = true;
                        updateUI();
                    }
                }
            });

            slot.addEventListener('mouseup', (e) => {
                if ((!inventoryOpen && !craftingTableOpen && !recipeBookOpen) || !player.heldItem || e.button !== 0) {
                    isDragging = false;
                    return;
                }
                const [prefix, index] = slot.id.split('-');
                const array = prefix === 'inv' ? player.inventory : prefix === 'hot' ? player.hotbar : prefix === 'craft' ? player.crafting : player.crafting3x3;
                if (array[index] && array[index].type === player.heldItem.type) {
                    array[index].count += player.heldItem.count;
                } else if (!array[index]) {
                    array[index] = { type: player.heldItem.type, count: player.heldItem.count };
                } else {
                    const temp = array[index];
                    array[index] = { type: player.heldItem.type, count: player.heldItem.count };
                    player.heldItem = temp;
                }
                player.heldItem = null;
                isDragging = false;
                updateUI();
            });
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button !== 0) return;
            isDragging = false;
            if ((inventoryOpen || craftingTableOpen || recipeBookOpen) && player.heldItem) {
                let placed = false;
                if (inventoryOpen && !craftingTableOpen && !recipeBookOpen) {
                    for (let i = 0; i < player.inventory.length; i++) {
                        if (!player.inventory[i]) {
                            player.inventory[i] = player.heldItem;
                            placed = true;
                            break;
                        } else if (player.inventory[i].type === player.heldItem.type) {
                            player.inventory[i].count += player.heldItem.count;
                            placed = true;
                            break;
                        }
                    }
                    if (!placed) {
                        for (let i = 0; i < player.hotbar.length; i++) {
                            if (!player.hotbar[i]) {
                                player.hotbar[i] = player.heldItem;
                                placed = true;
                                break;
                            } else if (player.hotbar[i].type === player.heldItem.type) {
                                player.hotbar[i].count += player.heldItem.count;
                                placed = true;
                                break;
                            }
                        }
                    }
                }
                if (!placed) addToInventoryWithCount(player.heldItem.type, player.heldItem.count);
                player.heldItem = null;
                updateUI();
            }
        });

        // Crafting logic
        function updateCraftingResult() {
            const craftResult = document.getElementById('craft-result');
            const craft3Result = document.getElementById('craft3-result');
            craftResult.innerHTML = craft3Result.innerHTML = '';

            const grid3x3 = craftingTableOpen ? player.crafting3x3 : player.crafting;
            const resultDiv = craftingTableOpen ? craft3Result : craftResult;

            if (grid3x3[0] && grid3x3[0].type === 'wood' && grid3x3[0].count >= 1) {
                resultDiv.innerHTML = `<div class="item-texture planks-texture"></div><span class="item-count">4</span>`;
            }
            if (grid3x3[0]?.type === 'planks' && grid3x3[1]?.type === 'planks' && grid3x3[3]?.type === 'planks' && grid3x3[4]?.type === 'planks') {
                resultDiv.innerHTML = `<div class="item-texture crafting-table-texture"></div><span class="item-count">1</span>`;
            }
            if (grid3x3[1]?.type === 'planks' && grid3x3[4]?.type === 'planks' && !grid3x3[0] && !grid3x3[2] && !grid3x3[3] && !grid3x3[5] && !grid3x3[6] && !grid3x3[7] && !grid3x3[8]) {
                resultDiv.innerHTML = `<div class="item-texture stick-texture"></div><span class="item-count">4</span>`;
            }
            if (grid3x3[0]?.type === 'planks' && grid3x3[1]?.type === 'planks' && grid3x3[2]?.type === 'planks' && grid3x3[4]?.type === 'stick' && grid3x3[7]?.type === 'stick') {
                resultDiv.innerHTML = `<div class="item-texture pickaxe-texture"></div><span class="item-count">1</span>`;
            }
            if (grid3x3[0]?.type === 'planks' && grid3x3[3]?.type === 'planks' && grid3x3[1]?.type === 'stick' && grid3x3[4]?.type === 'stick') {
                resultDiv.innerHTML = `<div class="item-texture axe-texture"></div><span class="item-count">1</span>`;
            }
            if (grid3x3[0]?.type === 'stone' && grid3x3[1]?.type === 'stone' && grid3x3[2]?.type === 'stone' && grid3x3[4]?.type === 'stick' && grid3x3[7]?.type === 'stick') {
                resultDiv.innerHTML = `<div class="item-texture stone-pickaxe-texture"></div><span class="item-count">1</span>`;
            }

            resultDiv.onclick = () => {
                if ((!inventoryOpen && !craftingTableOpen && !recipeBookOpen) || !resultDiv.innerHTML) return;
                if (grid3x3[0]?.type === 'wood') {
                    grid3x3[0].count--;
                    if (grid3x3[0].count === 0) grid3x3[0] = null;
                    addToInventoryWithCount('planks', 4);
                } else if (grid3x3[0]?.type === 'planks' && grid3x3[1]?.type === 'planks' && grid3x3[3]?.type === 'planks' && grid3x3[4]?.type === 'planks') {
                    for (let i of [0, 1, 3, 4]) {
                        grid3x3[i].count--;
                        if (grid3x3[i].count === 0) grid3x3[i] = null;
                    }
                    addToInventoryWithCount('crafting_table', 1);
                } else if (grid3x3[1]?.type === 'planks' && grid3x3[4]?.type === 'planks') {
                    grid3x3[1].count--;
                    grid3x3[4].count--;
                    if (grid3x3[1].count === 0) grid3x3[1] = null;
                    if (grid3x3[4].count === 0) grid3x3[4] = null;
                    addToInventoryWithCount('stick', 4);
                } else if (grid3x3[0]?.type === 'planks' && grid3x3[1]?.type === 'planks' && grid3x3[2]?.type === 'planks' && grid3x3[4]?.type === 'stick' && grid3x3[7]?.type === 'stick') {
                    for (let i of [0, 1, 2, 4, 7]) {
                        grid3x3[i].count--;
                        if (grid3x3[i].count === 0) grid3x3[i] = null;
                    }
                    addToInventoryWithCount('pickaxe', 1);
                    player.tools.pickaxe = true;
                } else if (grid3x3[0]?.type === 'planks' && grid3x3[3]?.type === 'planks' && grid3x3[1]?.type === 'stick' && grid3x3[4]?.type === 'stick') {
                    for (let i of [0, 3, 1, 4]) {
                        grid3x3[i].count--;
                        if (grid3x3[i].count === 0) grid3x3[i] = null;
                    }
                    addToInventoryWithCount('axe', 1);
                    player.tools.axe = true;
                } else if (grid3x3[0]?.type === 'stone' && grid3x3[1]?.type === 'stone' && grid3x3[2]?.type === 'stone' && grid3x3[4]?.type === 'stick' && grid3x3[7]?.type === 'stick') {
                    for (let i of [0, 1, 2, 4, 7]) {
                        grid3x3[i].count--;
                        if (grid3x3[i].count === 0) grid3x3[i] = null;
                    }
                    addToInventoryWithCount('stonePickaxe', 1);
                    player.tools.stonePickaxe = true;
                }
                updateUI();
            };
        }

        // Player movement
        const keys = {};
        document.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
        document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
        function canMove(x, y, z) {
            const chunkKey = `${Math.floor(x / chunkSize)},${Math.floor(z / chunkSize)}`;
            const key1 = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
            const key2 = `${Math.floor(x)},${Math.floor(y + 1)},${Math.floor(z)}`;
            return !chunks[chunkKey]?.keys[key1] && !chunks[chunkKey]?.keys[key2];
        }

        // Entity logic
        function createSheep() {
            const x = Math.floor(Math.random() * worldSize);
            const z = Math.floor(Math.random() * worldSize);
            const y = Math.max(2, Math.floor(noise(x, z) + 3)) + 1;
            const sheepId = `sheep-${Date.now()}-${Math.random()}`;
            const sheep = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.8, 0.8),
                materials.sheep
            );
            sheep.position.set(x + 0.5, y, z + 0.5);
            sheep.userData = { type: 'sheep', id: sheepId, health: 10, isRunning: false, speed: 2 };
            entities[sheepId] = sheep;
            scene.add(sheep);
        }

        function createPig() {
            const x = Math.floor(Math.random() * worldSize);
            const z = Math.floor(Math.random() * worldSize);
            const y = Math.max(2, Math.floor(noise(x, z) + 3)) + 1;
            const pigId = `pig-${Date.now()}-${Math.random()}`;
            const pig = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.8, 0.8),
                materials.pig
            );
            pig.position.set(x + 0.5, y, z + 0.5);
            pig.userData = { type: 'pig', id: pigId, health: 10, isRunning: false, speed: 2 };
            entities[pigId] = pig;
            scene.add(pig);
        }

        function createCow() {
            const x = Math.floor(Math.random() * worldSize);
            const z = Math.floor(Math.random() * worldSize);
            const y = Math.max(2, Math.floor(noise(x, z) + 3)) + 1;
            const cowId = `cow-${Date.now()}-${Math.random()}`;
            const cow = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.8, 0.8),
                materials.cow
            );
            cow.position.set(x + 0.5, y, z + 0.5);
            cow.userData = { type: 'cow', id: cowId, health: 10, isRunning: false, speed: 2 };
            entities[cowId] = cow;
            scene.add(cow);
        }

        function spawnEntities() {
            const now = Date.now();
            if (now - lastSheepSpawnTime >= (5 + Math.random() * 5) * 60 * 1000) {
                createSheep();
                lastSheepSpawnTime = now;
            }
            if (now - lastPigSpawnTime >= (5 + Math.random() * 5) * 60 * 1000) {
                createPig();
                lastPigSpawnTime = now;
            }
            if (now - lastCowSpawnTime >= (5 + Math.random() * 5) * 60 * 1000) {
                createCow();
                lastCowSpawnTime = now;
            }
        }

        function updateEntities() {
            for (let id in entities) {
                const entity = entities[id];
                if (entity.userData.isRunning) {
                    const dx = (player.x - entity.position.x) * 0.1;
                    const dz = (player.z - entity.position.z) * 0.1;
                    const newX = entity.position.x - dx * entity.userData.speed * clock.getDelta();
                    const newZ = entity.position.z - dz * entity.userData.speed * clock.getDelta();
                    if (canMove(newX, entity.position.y, newZ)) {
                        entity.position.x = newX;
                        entity.position.z = newZ;
                    }
                }
            }
        }

        function attackEntity(entityId) {
            const entity = entities[entityId];
            if (entity) {
                const damage = player.hotbar[player.selectedHotbar]?.type === 'axe' ? 3 : 1;
                entity.userData.health -= damage;
                entity.userData.isRunning = true;
                // Apply knockback
                const direction = new THREE.Vector3(player.x - entity.position.x, 0, player.z - entity.position.z).normalize();
                entity.position.x += direction.x * 0.5;
                entity.position.z += direction.z * 0.5;
                if (entity.userData.health <= 0) {
                    scene.remove(entity);
                    delete entities[entityId];
                    let muttonDrop;
                    if (entity.userData.type === 'sheep') muttonDrop = Math.floor(Math.random() * 2) + 1;
                    else if (entity.userData.type === 'pig') muttonDrop = Math.floor(Math.random() * 2) + 1;
                    else if (entity.userData.type === 'cow') muttonDrop = Math.floor(Math.random() * 2) + 1;
                    addToInventoryWithCount('mutton', muttonDrop);
                    player.health = Math.min(10, player.health + 1);
                    updateUI();
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.05);

            player.vy -= 0.5 * delta;
            player.y += player.vy;
            if (player.y <= 1 || !canMove(player.x, player.y - 1, player.z)) {
                player.y = Math.max(1, Math.ceil(player.y - 1) + 1);
                player.vy = 0;
                if (keys[' '] && mouseLocked && !inventoryOpen && !craftingTableOpen && !recipeBookOpen) player.vy = 0.3;
            }

            if (mouseLocked && !inventoryOpen && !craftingTableOpen && !recipeBookOpen) {
                const speed = 5 * delta;
                const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), player.yaw);
                const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), player.yaw);
                let newX = player.x, newZ = player.z;
                if (keys['w']) { newX += forward.x * speed; newZ += forward.z * speed; }
                if (keys['s']) { newX -= forward.x * speed; newZ -= forward.z * speed; }
                if (keys['a']) { newX -= right.x * speed; newZ -= right.z * speed; }
                if (keys['d']) { newX += right.x * speed; newZ += right.z * speed; }
                newX = Math.max(0.5, Math.min(worldSize - 0.5, newX));
                newZ = Math.max(0.5, Math.min(worldSize - 0.5, newZ));
                if (canMove(newX, player.y, player.z)) player.x = newX;
                if (canMove(player.x, player.y, newZ)) player.z = newZ;
            }

            camera.position.set(player.x, player.y + 1, player.z);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = player.yaw;
            camera.rotation.x = player.pitch;

            updateChunks();
            updateCrosshair();
            updateEntities();
            spawnEntities();
            renderer.render(scene, camera);
        }

        updateChunks();
        player.y = 10;
        updateUI();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>